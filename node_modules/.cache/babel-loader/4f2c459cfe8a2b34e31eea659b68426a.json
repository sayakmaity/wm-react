{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.preventScroll = exports.GridCell = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _styledComponents = _interopRequireDefault(require(\"styled-components\"));\n\nvar _add_minutes = _interopRequireDefault(require(\"date-fns/add_minutes\"));\n\nvar _add_hours = _interopRequireDefault(require(\"date-fns/add_hours\"));\n\nvar _add_days = _interopRequireDefault(require(\"date-fns/add_days\"));\n\nvar _start_of_day = _interopRequireDefault(require(\"date-fns/start_of_day\"));\n\nvar _is_same_minute = _interopRequireDefault(require(\"date-fns/is_same_minute\"));\n\nvar _format = _interopRequireDefault(require(\"date-fns/format\"));\n\nvar _typography = require(\"./typography\");\n\nvar _colors = _interopRequireDefault(require(\"./colors\"));\n\nvar _selectionSchemes = _interopRequireDefault(require(\"./selection-schemes\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n} // Import only the methods we need from date-fns in order to keep build size small\n\n\nconst Wrapper = _styledComponents.default.div.withConfig({\n  displayName: \"ScheduleSelector__Wrapper\",\n  componentId: \"sc-1ke4ka2-0\"\n})([\"display:flex;align-items:center;width:100%;user-select:none;\"]);\n\nconst Grid = _styledComponents.default.div.withConfig({\n  displayName: \"ScheduleSelector__Grid\",\n  componentId: \"sc-1ke4ka2-1\"\n})([\"display:grid;grid-template-columns:auto repeat(\", \",1fr);grid-template-rows:auto repeat(\", \",1fr);column-gap:\", \";row-gap:\", \";width:100%;\"], props => props.columns, props => props.rows, props => props.columnGap, props => props.rowGap);\n\nconst GridCell = _styledComponents.default.div.withConfig({\n  displayName: \"ScheduleSelector__GridCell\",\n  componentId: \"sc-1ke4ka2-2\"\n})([\"place-self:stretch;touch-action:none;\"]);\n\nexports.GridCell = GridCell;\n\nconst DateCell = _styledComponents.default.div.withConfig({\n  displayName: \"ScheduleSelector__DateCell\",\n  componentId: \"sc-1ke4ka2-3\"\n})([\"width:100%;height:25px;background-color:\", \";&:hover{background-color:\", \";}\"], props => props.selected ? props.selectedColor : props.unselectedColor, props => props.hoveredColor);\n\nconst DateLabel = (0, _styledComponents.default)(_typography.Subtitle).withConfig({\n  displayName: \"ScheduleSelector__DateLabel\",\n  componentId: \"sc-1ke4ka2-4\"\n})([\"@media (max-width:699px){font-size:12px;}margin:0;margin-bottom:4px;\"]);\nconst TimeText = (0, _styledComponents.default)(_typography.Text).withConfig({\n  displayName: \"ScheduleSelector__TimeText\",\n  componentId: \"sc-1ke4ka2-5\"\n})([\"@media (max-width:699px){font-size:10px;}text-align:right;margin:0;margin-right:4px;\"]);\n\nconst preventScroll = e => {\n  e.preventDefault();\n};\n\nexports.preventScroll = preventScroll;\n\nclass ScheduleSelector extends React.Component {\n  // documentMouseUpHandler: () => void = () => {}\n  // endSelection: () => void = () => {}\n  // handleTouchMoveEvent: (event: React.SyntheticTouchEvent<*>) => void\n  // handleTouchEndEvent: () => void\n  // handleMouseUpEvent: (date: Date) => void\n  // handleMouseEnterEvent: (date: Date) => void\n  // handleSelectionStartEvent: (date: Date) => void\n  static getDerivedStateFromProps(props, state) {\n    // As long as the user isn't in the process of selecting, allow prop changes to re-populate selection state\n    if (state.selectionStart == null) {\n      return {\n        selectionDraft: [...props.selection],\n        dates: ScheduleSelector.computeDatesMatrix(props)\n      };\n    }\n\n    return null;\n  }\n\n  static computeDatesMatrix(props) {\n    const startTime = (0, _start_of_day.default)(props.startDate);\n    const dates = [];\n    const minutesInChunk = Math.floor(60 / props.hourlyChunks);\n\n    for (let d = 0; d < props.numDays; d += 1) {\n      const currentDay = [];\n\n      for (let h = props.minTime; h < props.maxTime; h += 1) {\n        for (let c = 0; c < props.hourlyChunks; c += 1) {\n          currentDay.push((0, _add_minutes.default)((0, _add_hours.default)((0, _add_days.default)(startTime, d), h), c * minutesInChunk));\n        }\n      }\n\n      dates.push(currentDay);\n    }\n\n    return dates;\n  }\n\n  constructor(props) {\n    super(props);\n    this.cellToDate = new Map();\n    this.gridRef = null;\n\n    this.renderDateCellWrapper = time => {\n      const startHandler = () => {\n        this.handleSelectionStartEvent(time);\n      };\n\n      const selected = Boolean(this.state.selectionDraft.find(a => (0, _is_same_minute.default)(a, time)));\n      return /*#__PURE__*/React.createElement(GridCell, {\n        className: \"rgdp__grid-cell\",\n        role: \"presentation\",\n        key: time.toISOString() // Mouse handlers\n        ,\n        onMouseDown: startHandler,\n        onMouseEnter: () => {\n          this.handleMouseEnterEvent(time);\n        },\n        onMouseUp: () => {\n          this.handleMouseUpEvent(time);\n        } // Touch handlers\n        // Since touch events fire on the event where the touch-drag started, there's no point in passing\n        // in the time parameter, instead these handlers will do their job using the default Event\n        // parameters\n        ,\n        onTouchStart: startHandler,\n        onTouchMove: this.handleTouchMoveEvent,\n        onTouchEnd: this.handleTouchEndEvent\n      }, this.renderDateCell(time, selected));\n    };\n\n    this.renderDateCell = (time, selected) => {\n      const refSetter = dateCell => {\n        if (dateCell) {\n          this.cellToDate.set(dateCell, time);\n        }\n      };\n\n      if (this.props.renderDateCell) {\n        return this.props.renderDateCell(time, selected, refSetter);\n      } else {\n        return /*#__PURE__*/React.createElement(DateCell, {\n          selected: selected,\n          ref: refSetter,\n          selectedColor: this.props.selectedColor,\n          unselectedColor: this.props.unselectedColor,\n          hoveredColor: this.props.hoveredColor\n        });\n      }\n    };\n\n    this.renderTimeLabel = time => {\n      if (this.props.renderTimeLabel) {\n        return this.props.renderTimeLabel(time);\n      } else {\n        return /*#__PURE__*/React.createElement(TimeText, null, (0, _format.default)(time, this.props.timeFormat));\n      }\n    };\n\n    this.renderDateLabel = date => {\n      if (this.props.renderDateLabel) {\n        return this.props.renderDateLabel(date);\n      } else {\n        return /*#__PURE__*/React.createElement(DateLabel, null, (0, _format.default)(date, this.props.dateFormat));\n      }\n    };\n\n    this.state = {\n      selectionDraft: [...this.props.selection],\n      // copy it over\n      selectionType: null,\n      selectionStart: null,\n      isTouchDragging: false,\n      dates: ScheduleSelector.computeDatesMatrix(props)\n    };\n    this.selectionSchemeHandlers = {\n      linear: _selectionSchemes.default.linear,\n      square: _selectionSchemes.default.square\n    };\n    this.endSelection = this.endSelection.bind(this);\n    this.handleMouseUpEvent = this.handleMouseUpEvent.bind(this);\n    this.handleMouseEnterEvent = this.handleMouseEnterEvent.bind(this);\n    this.handleTouchMoveEvent = this.handleTouchMoveEvent.bind(this);\n    this.handleTouchEndEvent = this.handleTouchEndEvent.bind(this);\n    this.handleSelectionStartEvent = this.handleSelectionStartEvent.bind(this);\n  }\n\n  componentDidMount() {\n    // We need to add the endSelection event listener to the document itself in order\n    // to catch the cases where the users ends their mouse-click somewhere besides\n    // the date cells (in which case none of the DateCell's onMouseUp handlers would fire)\n    //\n    // This isn't necessary for touch events since the `touchend` event fires on\n    // the element where the touch/drag started so it's always caught.\n    document.addEventListener('mouseup', this.endSelection); // Prevent page scrolling when user is dragging on the date cells\n\n    this.cellToDate.forEach((value, dateCell) => {\n      if (dateCell && dateCell.addEventListener) {\n        // @ts-ignore\n        dateCell.addEventListener('touchmove', preventScroll, {\n          passive: false\n        });\n      }\n    });\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('mouseup', this.endSelection);\n    this.cellToDate.forEach((value, dateCell) => {\n      if (dateCell && dateCell.removeEventListener) {\n        // @ts-ignore\n        dateCell.removeEventListener('touchmove', preventScroll);\n      }\n    });\n  } // Performs a lookup into this.cellToDate to retrieve the Date that corresponds to\n  // the cell where this touch event is right now. Note that this method will only work\n  // if the event is a `touchmove` event since it's the only one that has a `touches` list.\n\n\n  getTimeFromTouchEvent(event) {\n    const {\n      touches\n    } = event;\n    if (!touches || touches.length === 0) return null;\n    const {\n      clientX,\n      clientY\n    } = touches[0];\n    const targetElement = document.elementFromPoint(clientX, clientY);\n\n    if (targetElement) {\n      const cellTime = this.cellToDate.get(targetElement);\n      return cellTime !== null && cellTime !== void 0 ? cellTime : null;\n    }\n\n    return null;\n  }\n\n  endSelection() {\n    this.props.onChange(this.state.selectionDraft);\n    this.setState({\n      selectionType: null,\n      selectionStart: null\n    });\n  } // Given an ending Date, determines all the dates that should be selected in this draft\n\n\n  updateAvailabilityDraft(selectionEnd, callback) {\n    const {\n      selectionType,\n      selectionStart\n    } = this.state;\n    if (selectionType === null || selectionStart === null) return;\n    let newSelection = [];\n\n    if (selectionStart && selectionEnd && selectionType) {\n      newSelection = this.selectionSchemeHandlers[this.props.selectionScheme](selectionStart, selectionEnd, this.state.dates);\n    }\n\n    let nextDraft = [...this.props.selection];\n\n    if (selectionType === 'add') {\n      nextDraft = Array.from(new Set([...nextDraft, ...newSelection]));\n    } else if (selectionType === 'remove') {\n      nextDraft = nextDraft.filter(a => !newSelection.find(b => (0, _is_same_minute.default)(a, b)));\n    }\n\n    this.setState({\n      selectionDraft: nextDraft\n    }, callback);\n  } // Isomorphic (mouse and touch) handler since starting a selection works the same way for both classes of user input\n\n\n  handleSelectionStartEvent(startTime) {\n    // Check if the startTime cell is selected/unselected to determine if this drag-select should\n    // add values or remove values\n    const timeSelected = this.props.selection.find(a => (0, _is_same_minute.default)(a, startTime));\n    this.setState({\n      selectionType: timeSelected ? 'remove' : 'add',\n      selectionStart: startTime\n    });\n  }\n\n  handleMouseEnterEvent(time) {\n    // Need to update selection draft on mouseup as well in order to catch the cases\n    // where the user just clicks on a single cell (because no mouseenter events fire\n    // in this scenario)\n    this.updateAvailabilityDraft(time);\n  }\n\n  handleMouseUpEvent(time) {\n    this.updateAvailabilityDraft(time); // Don't call this.endSelection() here because the document mouseup handler will do it\n  }\n\n  handleTouchMoveEvent(event) {\n    this.setState({\n      isTouchDragging: true\n    });\n    const cellTime = this.getTimeFromTouchEvent(event);\n\n    if (cellTime) {\n      this.updateAvailabilityDraft(cellTime);\n    }\n  }\n\n  handleTouchEndEvent() {\n    if (!this.state.isTouchDragging) {\n      // Going down this branch means the user tapped but didn't drag -- which\n      // means the availability draft hasn't yet been updated (since\n      // handleTouchMoveEvent was never called) so we need to do it now\n      this.updateAvailabilityDraft(null, () => {\n        this.endSelection();\n      });\n    } else {\n      this.endSelection();\n    }\n\n    this.setState({\n      isTouchDragging: false\n    });\n  }\n\n  renderFullDateGrid() {\n    const flattenedDates = [];\n    const numDays = this.state.dates.length;\n    const numTimes = this.state.dates[0].length;\n\n    for (let j = 0; j < numTimes; j += 1) {\n      for (let i = 0; i < numDays; i += 1) {\n        flattenedDates.push(this.state.dates[i][j]);\n      }\n    }\n\n    const dateGridElements = flattenedDates.map(this.renderDateCellWrapper);\n\n    for (let i = 0; i < numTimes; i += 1) {\n      const index = i * numDays;\n      const time = this.state.dates[0][i]; // Inject the time label at the start of every row\n\n      dateGridElements.splice(index + i, 0, this.renderTimeLabel(time));\n    }\n\n    return [\n    /*#__PURE__*/\n    // Empty top left corner\n    React.createElement(\"div\", {\n      key: \"topleft\"\n    }), // Top row of dates\n    ...this.state.dates.map((dayOfTimes, index) => /*#__PURE__*/React.cloneElement(this.renderDateLabel(dayOfTimes[0]), {\n      key: \"date-\".concat(index)\n    })), // Every row after that\n    ...dateGridElements.map((element, index) => /*#__PURE__*/React.cloneElement(element, {\n      key: \"time-\".concat(index)\n    }))];\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(Wrapper, null, /*#__PURE__*/React.createElement(Grid, {\n      columns: this.state.dates.length,\n      rows: this.state.dates[0].length,\n      columnGap: this.props.columnGap,\n      rowGap: this.props.rowGap,\n      ref: el => {\n        this.gridRef = el;\n      }\n    }, this.renderFullDateGrid()));\n  }\n\n}\n\nexports.default = ScheduleSelector;\nScheduleSelector.defaultProps = {\n  selection: [],\n  selectionScheme: 'square',\n  numDays: 7,\n  minTime: 9,\n  maxTime: 23,\n  hourlyChunks: 1,\n  startDate: new Date(),\n  timeFormat: 'ha',\n  dateFormat: 'M/D',\n  columnGap: '4px',\n  rowGap: '4px',\n  selectedColor: _colors.default.blue,\n  unselectedColor: _colors.default.paleBlue,\n  hoveredColor: _colors.default.lightBlue,\n  onChange: () => {}\n};","map":{"version":3,"mappings":"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","names":["Wrapper","styled","div","withConfig","displayName","componentId","Grid","props","columns","rows","columnGap","rowGap","GridCell","DateCell","selected","selectedColor","unselectedColor","hoveredColor","DateLabel","Subtitle","TimeText","Text","preventScroll","e","preventDefault","ScheduleSelector","React","Component","getDerivedStateFromProps","state","selectionStart","selectionDraft","selection","dates","computeDatesMatrix","startTime","startDate","minutesInChunk","Math","floor","hourlyChunks","d","numDays","currentDay","h","minTime","maxTime","c","push","constructor","cellToDate","Map","gridRef","renderDateCellWrapper","time","startHandler","handleSelectionStartEvent","Boolean","find","a","className","role","key","toISOString","onMouseDown","onMouseEnter","handleMouseEnterEvent","onMouseUp","handleMouseUpEvent","onTouchStart","onTouchMove","handleTouchMoveEvent","onTouchEnd","handleTouchEndEvent","renderDateCell","refSetter","dateCell","set","ref","renderTimeLabel","timeFormat","renderDateLabel","date","dateFormat","selectionType","isTouchDragging","selectionSchemeHandlers","linear","selectionSchemes","square","endSelection","bind","componentDidMount","document","addEventListener","forEach","value","passive","componentWillUnmount","removeEventListener","getTimeFromTouchEvent","event","touches","length","clientX","clientY","targetElement","elementFromPoint","cellTime","get","onChange","setState","updateAvailabilityDraft","selectionEnd","callback","newSelection","selectionScheme","nextDraft","Array","from","Set","filter","b","timeSelected","renderFullDateGrid","flattenedDates","numTimes","j","i","dateGridElements","map","index","splice","dayOfTimes","cloneElement","element","render","el","defaultProps","Date","colors","blue","paleBlue","lightBlue"],"sources":["/Users/sayakmaity/Desktop/CS279r/when2meet/node_modules/react-schedule-selector/src/lib/ScheduleSelector.tsx"],"sourcesContent":["import * as React from 'react'\nimport styled from 'styled-components'\n\n// Import only the methods we need from date-fns in order to keep build size small\nimport addMinutes from 'date-fns/add_minutes'\nimport addHours from 'date-fns/add_hours'\nimport addDays from 'date-fns/add_days'\nimport startOfDay from 'date-fns/start_of_day'\nimport isSameMinute from 'date-fns/is_same_minute'\nimport formatDate from 'date-fns/format'\n\nimport { Text, Subtitle } from './typography'\nimport colors from './colors'\nimport selectionSchemes, { SelectionSchemeType, SelectionType } from './selection-schemes'\n\nconst Wrapper = styled.div`\n  display: flex;\n  align-items: center;\n  width: 100%;\n  user-select: none;\n`\n\nconst Grid = styled.div<{ columns: number; rows: number; columnGap: string; rowGap: string }>`\n  display: grid;\n  grid-template-columns: auto repeat(${props => props.columns}, 1fr);\n  grid-template-rows: auto repeat(${props => props.rows}, 1fr);\n  column-gap: ${props => props.columnGap};\n  row-gap: ${props => props.rowGap};\n  width: 100%;\n`\n\nexport const GridCell = styled.div`\n  place-self: stretch;\n  touch-action: none;\n`\n\nconst DateCell = styled.div<{\n  selected: boolean\n  selectedColor: string\n  unselectedColor: string\n  hoveredColor: string\n}>`\n  width: 100%;\n  height: 25px;\n  background-color: ${props => (props.selected ? props.selectedColor : props.unselectedColor)};\n\n  &:hover {\n    background-color: ${props => props.hoveredColor};\n  }\n`\n\nconst DateLabel = styled(Subtitle)`\n  @media (max-width: 699px) {\n    font-size: 12px;\n  }\n  margin: 0;\n  margin-bottom: 4px;\n`\n\nconst TimeText = styled(Text)`\n  @media (max-width: 699px) {\n    font-size: 10px;\n  }\n  text-align: right;\n  margin: 0;\n  margin-right: 4px;\n`\n\ntype PropsType = {\n  selection: Array<Date>\n  selectionScheme: SelectionSchemeType\n  onChange: (newSelection: Array<Date>) => void\n  startDate: Date\n  numDays: number\n  minTime: number\n  maxTime: number\n  hourlyChunks: number\n  dateFormat: string\n  timeFormat: string\n  columnGap: string\n  rowGap: string\n  unselectedColor: string\n  selectedColor: string\n  hoveredColor: string\n  renderDateCell?: (datetime: Date, selected: boolean, refSetter: (dateCellElement: HTMLElement) => void) => JSX.Element\n  renderTimeLabel?: (time: Date) => JSX.Element\n  renderDateLabel?: (date: Date) => JSX.Element\n}\n\ntype StateType = {\n  // In the case that a user is drag-selecting, we don't want to call this.props.onChange() until they have completed\n  // the drag-select. selectionDraft serves as a temporary copy during drag-selects.\n  selectionDraft: Array<Date>\n  selectionType: SelectionType | null\n  selectionStart: Date | null\n  isTouchDragging: boolean\n  dates: Array<Array<Date>>\n}\n\nexport const preventScroll = (e: TouchEvent) => {\n  e.preventDefault()\n}\n\nexport default class ScheduleSelector extends React.Component<PropsType, StateType> {\n  selectionSchemeHandlers: { [key: string]: (startDate: Date, endDate: Date, foo: Array<Array<Date>>) => Date[] }\n  cellToDate: Map<Element, Date> = new Map()\n  // documentMouseUpHandler: () => void = () => {}\n  // endSelection: () => void = () => {}\n  // handleTouchMoveEvent: (event: React.SyntheticTouchEvent<*>) => void\n  // handleTouchEndEvent: () => void\n  // handleMouseUpEvent: (date: Date) => void\n  // handleMouseEnterEvent: (date: Date) => void\n  // handleSelectionStartEvent: (date: Date) => void\n  gridRef: HTMLElement | null = null\n\n  static defaultProps: Partial<PropsType> = {\n    selection: [],\n    selectionScheme: 'square',\n    numDays: 7,\n    minTime: 9,\n    maxTime: 23,\n    hourlyChunks: 1,\n    startDate: new Date(),\n    timeFormat: 'ha',\n    dateFormat: 'M/D',\n    columnGap: '4px',\n    rowGap: '4px',\n    selectedColor: colors.blue,\n    unselectedColor: colors.paleBlue,\n    hoveredColor: colors.lightBlue,\n    onChange: () => {}\n  }\n\n  static getDerivedStateFromProps(props: PropsType, state: StateType): Partial<StateType> | null {\n    // As long as the user isn't in the process of selecting, allow prop changes to re-populate selection state\n    if (state.selectionStart == null) {\n      return {\n        selectionDraft: [...props.selection],\n        dates: ScheduleSelector.computeDatesMatrix(props)\n      }\n    }\n    return null\n  }\n\n  static computeDatesMatrix(props: PropsType): Array<Array<Date>> {\n    const startTime = startOfDay(props.startDate)\n    const dates: Array<Array<Date>> = []\n    const minutesInChunk = Math.floor(60 / props.hourlyChunks)\n    for (let d = 0; d < props.numDays; d += 1) {\n      const currentDay = []\n      for (let h = props.minTime; h < props.maxTime; h += 1) {\n        for (let c = 0; c < props.hourlyChunks; c += 1) {\n          currentDay.push(addMinutes(addHours(addDays(startTime, d), h), c * minutesInChunk))\n        }\n      }\n      dates.push(currentDay)\n    }\n    return dates\n  }\n\n  constructor(props: PropsType) {\n    super(props)\n\n    this.state = {\n      selectionDraft: [...this.props.selection], // copy it over\n      selectionType: null,\n      selectionStart: null,\n      isTouchDragging: false,\n      dates: ScheduleSelector.computeDatesMatrix(props)\n    }\n\n    this.selectionSchemeHandlers = {\n      linear: selectionSchemes.linear,\n      square: selectionSchemes.square\n    }\n\n    this.endSelection = this.endSelection.bind(this)\n    this.handleMouseUpEvent = this.handleMouseUpEvent.bind(this)\n    this.handleMouseEnterEvent = this.handleMouseEnterEvent.bind(this)\n    this.handleTouchMoveEvent = this.handleTouchMoveEvent.bind(this)\n    this.handleTouchEndEvent = this.handleTouchEndEvent.bind(this)\n    this.handleSelectionStartEvent = this.handleSelectionStartEvent.bind(this)\n  }\n\n  componentDidMount() {\n    // We need to add the endSelection event listener to the document itself in order\n    // to catch the cases where the users ends their mouse-click somewhere besides\n    // the date cells (in which case none of the DateCell's onMouseUp handlers would fire)\n    //\n    // This isn't necessary for touch events since the `touchend` event fires on\n    // the element where the touch/drag started so it's always caught.\n    document.addEventListener('mouseup', this.endSelection)\n\n    // Prevent page scrolling when user is dragging on the date cells\n    this.cellToDate.forEach((value, dateCell) => {\n      if (dateCell && dateCell.addEventListener) {\n        // @ts-ignore\n        dateCell.addEventListener('touchmove', preventScroll, { passive: false })\n      }\n    })\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('mouseup', this.endSelection)\n    this.cellToDate.forEach((value, dateCell) => {\n      if (dateCell && dateCell.removeEventListener) {\n        // @ts-ignore\n        dateCell.removeEventListener('touchmove', preventScroll)\n      }\n    })\n  }\n\n  // Performs a lookup into this.cellToDate to retrieve the Date that corresponds to\n  // the cell where this touch event is right now. Note that this method will only work\n  // if the event is a `touchmove` event since it's the only one that has a `touches` list.\n  getTimeFromTouchEvent(event: React.TouchEvent<any>): Date | null {\n    const { touches } = event\n    if (!touches || touches.length === 0) return null\n    const { clientX, clientY } = touches[0]\n    const targetElement = document.elementFromPoint(clientX, clientY)\n    if (targetElement) {\n      const cellTime = this.cellToDate.get(targetElement)\n      return cellTime ?? null\n    }\n    return null\n  }\n\n  endSelection() {\n    this.props.onChange(this.state.selectionDraft)\n    this.setState({\n      selectionType: null,\n      selectionStart: null\n    })\n  }\n\n  // Given an ending Date, determines all the dates that should be selected in this draft\n  updateAvailabilityDraft(selectionEnd: Date | null, callback?: () => void) {\n    const { selectionType, selectionStart } = this.state\n\n    if (selectionType === null || selectionStart === null) return\n\n    let newSelection: Array<Date> = []\n    if (selectionStart && selectionEnd && selectionType) {\n      newSelection = this.selectionSchemeHandlers[this.props.selectionScheme](\n        selectionStart,\n        selectionEnd,\n        this.state.dates\n      )\n    }\n\n    let nextDraft = [...this.props.selection]\n    if (selectionType === 'add') {\n      nextDraft = Array.from(new Set([...nextDraft, ...newSelection]))\n    } else if (selectionType === 'remove') {\n      nextDraft = nextDraft.filter(a => !newSelection.find(b => isSameMinute(a, b)))\n    }\n\n    this.setState({ selectionDraft: nextDraft }, callback)\n  }\n\n  // Isomorphic (mouse and touch) handler since starting a selection works the same way for both classes of user input\n  handleSelectionStartEvent(startTime: Date) {\n    // Check if the startTime cell is selected/unselected to determine if this drag-select should\n    // add values or remove values\n    const timeSelected = this.props.selection.find(a => isSameMinute(a, startTime))\n    this.setState({\n      selectionType: timeSelected ? 'remove' : 'add',\n      selectionStart: startTime\n    })\n  }\n\n  handleMouseEnterEvent(time: Date) {\n    // Need to update selection draft on mouseup as well in order to catch the cases\n    // where the user just clicks on a single cell (because no mouseenter events fire\n    // in this scenario)\n    this.updateAvailabilityDraft(time)\n  }\n\n  handleMouseUpEvent(time: Date) {\n    this.updateAvailabilityDraft(time)\n    // Don't call this.endSelection() here because the document mouseup handler will do it\n  }\n\n  handleTouchMoveEvent(event: React.TouchEvent) {\n    this.setState({ isTouchDragging: true })\n    const cellTime = this.getTimeFromTouchEvent(event)\n    if (cellTime) {\n      this.updateAvailabilityDraft(cellTime)\n    }\n  }\n\n  handleTouchEndEvent() {\n    if (!this.state.isTouchDragging) {\n      // Going down this branch means the user tapped but didn't drag -- which\n      // means the availability draft hasn't yet been updated (since\n      // handleTouchMoveEvent was never called) so we need to do it now\n      this.updateAvailabilityDraft(null, () => {\n        this.endSelection()\n      })\n    } else {\n      this.endSelection()\n    }\n    this.setState({ isTouchDragging: false })\n  }\n\n  renderDateCellWrapper = (time: Date): JSX.Element => {\n    const startHandler = () => {\n      this.handleSelectionStartEvent(time)\n    }\n\n    const selected = Boolean(this.state.selectionDraft.find(a => isSameMinute(a, time)))\n\n    return (\n      <GridCell\n        className=\"rgdp__grid-cell\"\n        role=\"presentation\"\n        key={time.toISOString()}\n        // Mouse handlers\n        onMouseDown={startHandler}\n        onMouseEnter={() => {\n          this.handleMouseEnterEvent(time)\n        }}\n        onMouseUp={() => {\n          this.handleMouseUpEvent(time)\n        }}\n        // Touch handlers\n        // Since touch events fire on the event where the touch-drag started, there's no point in passing\n        // in the time parameter, instead these handlers will do their job using the default Event\n        // parameters\n        onTouchStart={startHandler}\n        onTouchMove={this.handleTouchMoveEvent}\n        onTouchEnd={this.handleTouchEndEvent}\n      >\n        {this.renderDateCell(time, selected)}\n      </GridCell>\n    )\n  }\n\n  renderDateCell = (time: Date, selected: boolean): JSX.Element => {\n    const refSetter = (dateCell: HTMLElement | null) => {\n      if (dateCell) {\n        this.cellToDate.set(dateCell, time)\n      }\n    }\n    if (this.props.renderDateCell) {\n      return this.props.renderDateCell(time, selected, refSetter)\n    } else {\n      return (\n        <DateCell\n          selected={selected}\n          ref={refSetter}\n          selectedColor={this.props.selectedColor}\n          unselectedColor={this.props.unselectedColor}\n          hoveredColor={this.props.hoveredColor}\n        />\n      )\n    }\n  }\n\n  renderTimeLabel = (time: Date): JSX.Element => {\n    if (this.props.renderTimeLabel) {\n      return this.props.renderTimeLabel(time)\n    } else {\n      return <TimeText>{formatDate(time, this.props.timeFormat)}</TimeText>\n    }\n  }\n\n  renderDateLabel = (date: Date): JSX.Element => {\n    if (this.props.renderDateLabel) {\n      return this.props.renderDateLabel(date)\n    } else {\n      return <DateLabel>{formatDate(date, this.props.dateFormat)}</DateLabel>\n    }\n  }\n\n  renderFullDateGrid(): Array<JSX.Element> {\n    const flattenedDates: Date[] = []\n    const numDays = this.state.dates.length\n    const numTimes = this.state.dates[0].length\n    for (let j = 0; j < numTimes; j += 1) {\n      for (let i = 0; i < numDays; i += 1) {\n        flattenedDates.push(this.state.dates[i][j])\n      }\n    }\n    const dateGridElements = flattenedDates.map(this.renderDateCellWrapper)\n    for (let i = 0; i < numTimes; i += 1) {\n      const index = i * numDays\n      const time = this.state.dates[0][i]\n      // Inject the time label at the start of every row\n      dateGridElements.splice(index + i, 0, this.renderTimeLabel(time))\n    }\n    return [\n      // Empty top left corner\n      <div key=\"topleft\" />,\n      // Top row of dates\n      ...this.state.dates.map((dayOfTimes, index) =>\n        React.cloneElement(this.renderDateLabel(dayOfTimes[0]), { key: `date-${index}` })\n      ),\n      // Every row after that\n      ...dateGridElements.map((element, index) => React.cloneElement(element, { key: `time-${index}` }))\n    ]\n  }\n\n  render(): JSX.Element {\n    return (\n      <Wrapper>\n        <Grid\n          columns={this.state.dates.length}\n          rows={this.state.dates[0].length}\n          columnGap={this.props.columnGap}\n          rowGap={this.props.rowGap}\n          ref={el => {\n            this.gridRef = el\n          }}\n        >\n          {this.renderFullDateGrid()}\n        </Grid>\n      </Wrapper>\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}